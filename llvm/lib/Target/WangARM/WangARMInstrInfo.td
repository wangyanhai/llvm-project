//===----------------------------------------------------------------------===//
// Type profiles
//===----------------------------------------------------------------------===//

def MoveImm32Ty : SDTypeProfile<1, 1, [ SDTCisSameAs<0, 1>, SDTCisInt<0> ]>;

def SDT_WangARMCallSeqStart : SDCallSeqStart<[ SDTCisVT<0, i32> ]>;

def SDT_WangARMCallSeqEnd   : SDCallSeqEnd<[
  SDTCisVT<0, i32>, SDTCisVT<1, i32>
]>;

def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_WangARMCallSeqStart,
                           [SDNPHasChain, SDNPOutGlue]>;
def callseq_end   : SDNode<"ISD::CALLSEQ_END",   SDT_WangARMCallSeqEnd,
                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;

def SDT_WangARMCall    : SDTypeProfile<0, -1, [SDTCisPtrTy<0>]>;

//===----------------------------------------------------------------------===//
// Custom SDNodes.
//===----------------------------------------------------------------------===//
def WangARMRetFlag    : SDNode<"WangARMISD::RET_FLAG", SDTNone,
                           [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;

def load_sym : SDNode<"WangARMISD::LOAD_SYM", SDTIntUnaryOp>;

def movei32 : SDNode<"WangARMISD::MOVEi32", MoveImm32Ty>;

def wangarm_call
    : SDNode<"WangARMISD::CALL", SDT_WangARMCall,
             [ SDNPHasChain, SDNPOptInGlue, SDNPOutGlue, SDNPVariadic ]>;

//===----------------------------------------------------------------------===//
// Operand Definitions.
//===----------------------------------------------------------------------===//

def bl_target : Operand<i32>;

def memsrc : Operand<i32> {
  let MIOperandInfo = (ops GRRegs, i32imm);
  let PrintMethod = "printAddrModeMemSrc";
  let EncoderMethod = "getMemSrcValue";
}

def i32imm_lo : Operand<i32>, ImmLeaf<i32, [{
  return Imm >= 0 && Imm < 65536;
}]>;

// Call target for ARM. Handles conditional/unconditional
// FIXME: rename bl_target to t2_bltarget?
def arm_bl_target : Operand<i32> {
  //let ParserMatchClass = ARMBranchTarget;
  let EncoderMethod = "getARMBLTargetOpValue";
  let OperandType = "OPERAND_PCREL";
}

//===----------------------------------------------------------------------===//
// Complex Pattern Definitions.
//===----------------------------------------------------------------------===//

def addr : ComplexPattern<iPTR, 2, "SelectAddr", [], []>;


def WangARMimm8 : Operand<i32>, ImmLeaf<i32, [{  return Imm >= 0 && Imm < 256; }]>;

//===----------------------------------------------------------------------===//
// ALU Instructions
//===----------------------------------------------------------------------===//

multiclass BinOp<bits<4> opcode, string opstr, SDNode opnode> {
  def rr : ALUInst<opcode, (outs GRRegs:$dst),
                   (ins GRRegs:$src1, GRRegs:$src2),
                   !strconcat(opstr, " $dst, $src1, $src2"),
                   [(set i32:$dst, (opnode i32:$src1, i32:$src2))]> {
    bits<4> dst;
    bits<4> src1;
    bits<4> src2;
    let Inst{25} = 0;
    let Inst{20} = 0;  // We never update flags
    let Inst{19-16} = src1;
    let Inst{15-12} = dst;
    let Inst{11-4}  = 0b00000000;
    let Inst{3-0}   = src2;
  }
  def ri : ALUInst<opcode, (outs GRRegs:$dst),
                   (ins GRRegs:$src1, i32imm:$imm),
                   !strconcat(opstr, " $dst, $src1, $imm"),
                   [(set i32:$dst, (opnode i32:$src1, WangARMimm8:$imm))]> {
    bits<4> dst;
    bits<4> src1;
    bits<12> imm;
    let Inst{25} = 1;
    let Inst{20} = 0;  // We never update flags
    let Inst{19-16} = dst;
    let Inst{15-12} = src1;
    let Inst{11-0}  = imm;
  }
}

defm ADD  : BinOp<0b0100, "add", add>;
defm SUB  : BinOp<0b0010, "sub", sub>;

//===----------------------------------------------------------------------===//
// Return Instructions
//===----------------------------------------------------------------------===//

let isTerminator = 1, isReturn = 1, isBarrier = 1, Uses = [LR] in {
  def RET : InstWang<(outs), (ins variable_ops),
                    "bx lr",  [(WangARMRetFlag)]> {
      let Inst{27-0}  = 0b0001001011111111111100011110;
  }
}

//===----------------------------------------------------------------------===//
// Multiply Instructions
//===----------------------------------------------------------------------===//

def MUL  : MulInst<0b0000000, (outs GRRegs:$dst),
                   (ins GRRegs:$src1, GRRegs:$src2),
                   "mul $dst, $src1, $src2",
                   [(set i32:$dst, (mul i32:$src1, i32:$src2))]> {
  bits<4> dst;
  bits<4> src1;
  bits<4> src2;
  let Inst{19-16} = dst;
  let Inst{15-12} = 0b0000;
  let Inst{11-8}  = src2;
  let Inst{3-0}   = src1;
}

def MLA  : MulInst<0b0000001, (outs GRRegs:$dst),
                   (ins GRRegs:$src1, GRRegs:$src2, GRRegs:$src3),
                   "mla $dst, $src1, $src2, $src3",
                   [(set i32:$dst, (add (mul i32:$src1, i32:$src2),
                                         i32:$src3))]> {
  bits<4> dst;
  bits<4> src1;
  bits<4> src2;
  bits<4> src3;
  let Inst{19-16} = dst;
  let Inst{15-12} = src3;
  let Inst{11-8}  = src2;
  let Inst{3-0}   = src1;
}

//===----------------------------------------------------------------------===//
// Mov Instructions
//===----------------------------------------------------------------------===//
def MOVrr  : ALUInst<0b1101, (outs GRRegs:$dst), (ins GRRegs:$src),
                     "mov $dst, $src",
                     [/* No pattern */]> {
  bits<4> dst;
  bits<4> src;
  let Inst{25-27} = 0b000;  
  let Inst{20} = 0;
  let Inst{19-16} = 0b0000;
  let Inst{15-12} = dst;
  let Inst{11-4}  = 0b00000000;
  let Inst{3-0} = src;
}

//===----------------------------------------------------------------------===//
// Mov Immediate Instructions
//===----------------------------------------------------------------------===//

class MOV<bits<4> opcode, string opstr, dag ins, list<dag>pattern>
    : ALUInst<opcode, (outs GRRegs:$dst), ins,
              !strconcat(opstr, " $dst, $imm"), pattern> {
  bits<4> dst;
  bits<16> imm;
  let Inst{15-12} = dst;
  let Inst{11-0}  = imm{11-0};
  let Inst{19-16} = imm{15-12};
  let Inst{20} = 0;
  let Inst{25} = 1;
}

def MOVLOi16 : MOV<0b1000, "movw", (ins i32imm:$imm),
                  [(set i32:$dst, i32imm_lo:$imm)]>;
def MOVHIi16 : MOV<0b1010, "movt", (ins GRRegs:$src1, i32imm:$imm),
                  [/* No Pattern */]>;

def MOVi32 : InstWang<(outs GRRegs:$dst), (ins i32imm:$src), "movi32",[(set i32:$dst, (movei32 imm:$src))]> {
  let isPseudo = 1;
}

//===----------------------------------------------------------------------===//
// Call Instructions
//===----------------------------------------------------------------------===//
let isCall = 1, Defs = [LR], Uses = [SP] in {
//此处存在缺陷：0b1011 是bl/blx imm24 的指令编码，不支持bl reg.
//  def BLr : BranchInst<0b1011, (outs), (ins GRRegs:$addr),  
//                      "bl $addr",
//                      [(wangarm_call i32:$addr)]> {
//    bits<4> addr;             
//    let Inst{31-28} = 0b1110;  //忽略指令的条件码，即无条件地执行
//    let Inst{3-0} = addr;
//  }

  def BLi  : BranchInst<0b1011, (outs), (ins arm_bl_target:$func),  
                      "bl\t$func",
                      [(wangarm_call tglobaladdr:$func)]> {
    bits<24> func;
    let Inst{23-0} = func;
    let DecoderMethod = "DecodeBranchImmInstruction";
  }
}




def : Pattern<(i32 (load_sym tglobaladdr:$addr)),  [(MOVi32 $addr)]>;

//===----------------------------------------------------------------------===//
// Pseudo Instructions
//===----------------------------------------------------------------------===//

let Defs = [SP], Uses = [SP] in {
def ADJCALLSTACKDOWN : WangARMPseudoInst<(outs), (ins i32imm:$amt, i32imm:$amt2),
                                    "# ADJCALLSTACKDOWN $amt",
                                    [(callseq_start timm:$amt, timm:$amt2)]>;
def ADJCALLSTACKUP   : WangARMPseudoInst<(outs), (ins i32imm:$amt1, i32imm:$amt2),
                                    "# ADJCALLSTACKUP $amt1",
                                    [(callseq_end timm:$amt1, timm:$amt2)]>;
}


//===----------------------------------------------------------------------===//
// Load/Store Instructions
//===----------------------------------------------------------------------===//

def LDR  : InstWang<(outs GRRegs:$val), (ins memsrc:$addr),
                   "ldr $val, $addr",
                   [(set i32:$val, (load addr:$addr))]> {
  bits<4> val;
  bits<16> addr;
  let Inst{27-25} = 0b010;
  let Inst{24} = 1; // not indexed
  let Inst{23} = 1; // add ofset
  let Inst{22} = 0;
  let Inst{21} = 0; // no writeback
  let Inst{20} = 1; // load
  let Inst{19-16} = addr{15-12};
  let Inst{15-12} = val;
  let Inst{11-0} = addr{11-0};
}

def STR : InstWang<(outs), (ins GRRegs:$val, memsrc:$addr),
                  "str $val, $addr",
                  [(store i32:$val, addr:$addr)]> {
  bits<16> addr;
  bits<4> val;
  let Inst{27-25} = 0b010;
  let Inst{24} = 1; // not indexed
  let Inst{23} = 1; // add offset
  let Inst{22} = 0;
  let Inst{21} = 0; // no writeback
  let Inst{20} = 0; // store
  let Inst{19-16} = addr{15-12};
  let Inst{15-12} = val;
  let Inst{11-0} = addr{11-0};
}

